#!/usr/bin/perl
use strict;
use warnings;

# Код, заключенный в блок BEGIN, выполняется на этапе компиляции, 
# то есть настолько рано, насколько его вообще возможно выполнить. 
# Выполнение блока начинается в тот момент, когда интерпретатор perl обнаруживает закрывающую блок фигурную скобку, 
# до того, как интерпретатор попытается обработать код, идущий следом за ней.

# print "1\n";
# BEGIN { print "2\n"; }
# print "3\n";

# Выводом данной программы будет являться:

# 2
# 1
# 3

# Блок BEGIN используется, как правило, для первичных проверок и настроек программы, 
# зависящих от версии интерпретатора, имеющихся в системе модулей, файлов и другого окружения. 
# В зависимости от результатов данных проверок, программа может до начала своего выполнения 
# выбрать наиболее подходящие модули и настройки, либо, в случае невозможности корректной работы, 
# аварийно остановиться до того, как основной код начнет свое выполнение.

# Директива use

# Наиболее удобным и распространенным на практике способом загрузки модулей является директива use. 
# В качестве аргумента она принимает имя пакета (строго без кавычек). 
# Поведение директивы в простейшем случае похоже на поведение функции require, с тем лишь исключением, 
# что use выполняется на этапе компиляции исходного кода (в констексте блока BEGIN).

# use Some::Module;


# BEGIN { require Some::Module; }

# На самом деле, есть и отличия. Кроме вызова require для загрузки модуля, 
# use автоматически (тоже на этапе компиляции) вызывает из загружаемого модуля функцию import, 
# которая может выполнять произвольные действия - при условии, что данная функция существует. Ей можно даже передать аргументы:

# use Some::Module ('arg1', 'arg2');

# BEGIN {
#     require Some::Module;
#     Some::Module::import('Some::Module', 'arg1', 'arg2');
# }

# Вызов функции import выглядит странно, но данные особенности будут объяснены в последующих лекциях.

# Есть способ подавить вызов функции import при загрузке модуля: достаточно в явном виде указать пустой список аргументов:

# use Some::Module ();

# Директива no

# Поведение директивы no совершенно аналогично поведению use, с одним небольшим исключением: 
# вместо функции import из модуля будет вызвана функция unimport. 
# Однако, данная функциональность используется почти исключительно в модулях-прагмах,
#  о которых будет рассказано в последующих лекциях.


# Управление версиями

# Директиве use, кроме прочего, можно указать версию модуля, которая требуется для работы программы. 
# В случае, если модуль данной (или более старшей) версии не может быть загружен, программа завершается с ошибкой. 
# Задание версии может быть выполнено примерно так:

# use Some::Module 1.23;

# В случае, если версия содержит более двух чисел, допускается еще один формат значения версии:

# use Some::Module v1.23.45;

# Обратите внимание на отсутствие кавычек вокруг v1.23.45.

# Модуль может указать свою версию двумя способами. Первый из них самый простой: объявить переменную пакета с именем $VERSION:

# package Some::Module;
# $Some::Module::VERSION = 1.23;

# Однако, в современных версиях perl появился более наглядный синтаксис:

# package Some::Module 1.23;

# При помощи команды use можн даже затребовать нужную версию интерпретатора perl:

# use v5.10;

# В данном случае, программа аварийно завершится, если ее запустить при помощи интерпретатора младше чем 5.10.


