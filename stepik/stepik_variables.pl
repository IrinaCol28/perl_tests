#!/usr/bin/perl
use strict;
use warnings;

# Переменные уровня пакета обычно определяются при помощи ключевого слова our. 
# После создания к таким переменным можно обращаться по полному имени (fqn) из кода, находящегося в любом пакете. 
# В "родном" же пакете к переменным можно обращаться и напрямую, по обычному короткому имени.

# package Local::Math;
# our $PI = 3.1415926;
# print $PI;                 # 3.1415926


# package main;
# print $Local::Math::PI;    # 3.1415926

# Однако, поведение our становится менее очевидным, если в одном файле объявлено несколько пакетов. 
# Дело в том, что область видимости объявления our ограничена концом текущего файла, и действует "сквозь" все пакеты, 
# встречающиеся ниже объявления переменной. Таким образом, можно считать, что our не только создает переменную пакета, 
# но и создает для нее алиас, видимый до конца файла.

# Локальные переменные

# Локальные переменные создаются при помощи ключевого слова my. 
# К таким переменным нельзя обращаться по полному имени; область видимости my-переменных ограничена блоком, 
# где объявлена переменная, либо фрагментом кода, переданного в функцию eval, либо концом текущего файла. 
# Интересной особенностью локальных переменных является то, что в зоне видимости одной переменной есть возможность 
# создать еще одну переменную с таким же именем (если зона ее видимости будет вложена в зону видимости переменной номер 1).

# my $x = 1;
# {
#     my $x = 2;
#     print $x;     # 2
# }
# print $x;         # 1
# print 

# Переменные, сохраняющие значение

# Такие переменные определяются при помощи ключевого слова state. 
# Данный тип переменных является полным аналогом переменных my с одним лишь исключением: 
# при повторном вызове кода, 
# в котором объявлена my-переменная, она инициализируется заново, 
# тогда как state-переменная сохраняет свое значение:

# sub test {
#     state $x = 1;
#     $x++;
#     print "$x\n";
# }
# test();    # 2
# test();    # 3
# test();    # 4

# Локализация глобальных переменных

# Помимо my, state и our, есть еще внешне похожее на них ключевое слово local, 
# которое, однако, не имеет с ними ничего общего. 
# В perl существует возможность временно присвоить любой глобальной переменной некоторое значение до конца области видимости:

# {
#     package Test;
#     our $x = 123;
#     sub bark { print $x; }
# }

# Test::bark();                 # 123
# {
#     local $Test::x = 321;
#     Test::bark();             # 321
# }
# Test::bark();                 # 123

# Чаще всего это используется в тех случаях, когда требуется временно поменять поведение и восстановить старое поведение после. 
# В частности, можно временно изменить значения служебных переменных. 
# Поскольку эти переменные используются внутренними механизмами perl, их прежнее значение должно быть возвращено. 
# римером использование данной возможности является переопределение служебной переменной $/, 
# которая определяет перенос конца строки, чтобы считывать файлы не построчно, а целиком. 
# На самом деле с помощью local можно переопределять не только переменные, но даже ключи в хеше. 
# Более того, существует конструкция delete local, которая удалит ключ, но только локально до конца области видимости, 
# а потом вернет его на место.

# Возможности ключевого слова local безграничны,
#  но рекомендуется не злоупотреблять им, потому что в сложных конструкциях его действие может быть не очевидно.


# require Magick;
# print MagickNumber();


# chomp (my $package=<STDIN>);
# my $file_path=$package;
# $file_path=~s|::|/|g;
# $file_path.=".pm";
# for my $inc_path(@INC){
#     print "$inc_path/$file_path\n";
# }

# Какие значения будут установленны у переменных   $foo и $bar после выполнения данного участка кода?

my $foo = 1;
my $code = '++$foo; my $foo = 3;';

my $bar = eval $code;
print $foo; #2
print $bar; #3
